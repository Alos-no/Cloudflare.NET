<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Presigned URLs | Cloudflare.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Presigned URLs | Cloudflare.NET ">
      <meta name="description" content="Cloudflare.NET SDK - A comprehensive C# client library for the Cloudflare REST API. Manage DNS, Zones, R2 storage, Workers, WAF, and security with strongly-typed .NET code.">
      
      <link rel="icon" href="../../images/favicon.svg">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/Alos-no/Cloudflare.NET/blob/main/docs/articles/r2/presigned-urls.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

      <script async src="https://www.googletagmanager.com/gtag/js?id=G-J3X1J125E2"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-J3X1J125E2');
      </script>
  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/logo.svg" alt="Cloudflare.NET">
            Cloudflare.NET
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="presigned-urls">Presigned URLs</h1>

<p>Generate secure, time-limited URLs that allow clients to upload directly to R2 without exposing credentials.</p>
<h2 id="overview">Overview</h2>
<pre><code class="lang-csharp">public class PresignedService(IR2Client r2)
{
    public string GenerateUploadUrl(string key, long fileSize, string contentType)
    {
        return r2.CreatePresignedPutUrl(&quot;my-bucket&quot;, new PresignedPutRequest(
            Key: key,
            ExpiresAfter: TimeSpan.FromMinutes(15),
            ContentLength: fileSize,
            ContentType: contentType
        ));
    }
}
</code></pre>
<h2 id="single-part-presigned-url">Single-Part Presigned URL</h2>
<p>Generate a URL for direct file upload:</p>
<pre><code class="lang-csharp">var url = r2.CreatePresignedPutUrl(&quot;my-bucket&quot;, new PresignedPutRequest(
    Key: &quot;uploads/document.pdf&quot;,
    ExpiresAfter: TimeSpan.FromMinutes(30),
    ContentLength: 1024 * 1024 * 10, // 10 MB
    ContentType: &quot;application/pdf&quot;
));

Console.WriteLine($&quot;Upload URL: {url}&quot;);
</code></pre>
<h3 id="presignedputrequest-properties">PresignedPutRequest Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Key</code></td>
<td><code>string</code></td>
<td>Yes</td>
<td>Object key (path)</td>
</tr>
<tr>
<td><code>ExpiresAfter</code></td>
<td><code>TimeSpan</code></td>
<td>Yes</td>
<td>URL validity duration</td>
</tr>
<tr>
<td><code>ContentLength</code></td>
<td><code>long</code></td>
<td>Yes</td>
<td>Exact file size in bytes</td>
</tr>
<tr>
<td><code>ContentType</code></td>
<td><code>string</code></td>
<td>Yes</td>
<td>MIME type of the file</td>
</tr>
<tr>
<td><code>Conditions</code></td>
<td><code>IEnumerable&lt;S3PostCondition&gt;?</code></td>
<td>No</td>
<td>Additional S3 conditions</td>
</tr>
<tr>
<td><code>HeadersToSign</code></td>
<td><code>IReadOnlyDictionary&lt;string, string&gt;?</code></td>
<td>No</td>
<td>Headers to include in signature</td>
</tr>
</tbody>
</table>
<h2 id="using-presigned-urls">Using Presigned URLs</h2>
<h3 id="server-side-generate-url">Server-Side (Generate URL)</h3>
<pre><code class="lang-csharp">[HttpPost(&quot;upload-url&quot;)]
public IActionResult GetUploadUrl([FromBody] UploadRequest request)
{
    var url = r2.CreatePresignedPutUrl(&quot;uploads&quot;, new PresignedPutRequest(
        Key: $&quot;{Guid.NewGuid()}/{request.FileName}&quot;,
        ExpiresAfter: TimeSpan.FromMinutes(15),
        ContentLength: request.FileSize,
        ContentType: request.ContentType
    ));

    return Ok(new { uploadUrl = url });
}
</code></pre>
<h3 id="client-side-javascript">Client-Side (JavaScript)</h3>
<pre><code class="lang-javascript">// Get presigned URL from your API
const { uploadUrl } = await fetch('/api/upload-url', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        fileName: file.name,
        fileSize: file.size,
        contentType: file.type
    })
}).then(r =&gt; r.json());

// Upload directly to R2
await fetch(uploadUrl, {
    method: 'PUT',
    headers: {
        'Content-Type': file.type,
        'Content-Length': file.size
    },
    body: file
});
</code></pre>
<h2 id="multipart-presigned-urls">Multipart Presigned URLs</h2>
<p>Generate presigned URLs for multipart upload parts:</p>
<h3 id="single-part">Single Part</h3>
<pre><code class="lang-csharp">var partUrl = r2.CreatePresignedUploadPartUrl(&quot;my-bucket&quot;, new PresignedUploadPartRequest(
    Key: &quot;uploads/large-file.zip&quot;,
    UploadId: &quot;your-upload-id&quot;,
    PartNumber: 1,
    ExpiresAfter: TimeSpan.FromMinutes(60),
    ContentLength: 100 * 1024 * 1024, // 100 MiB
    ContentType: &quot;application/octet-stream&quot;
));
</code></pre>
<h3 id="batch-presigned-urls">Batch Presigned URLs</h3>
<p>Generate URLs for all parts at once:</p>
<pre><code class="lang-csharp">var partUrls = r2.CreatePresignedUploadPartsUrls(&quot;my-bucket&quot;, new PresignedUploadPartsRequest(
    Key: &quot;uploads/large-file.zip&quot;,
    UploadId: &quot;your-upload-id&quot;,
    PartNumbers: Enumerable.Range(1, 10).ToArray(), // Parts 1-10
    ExpiresAfter: TimeSpan.FromHours(1),
    ContentLength: 100 * 1024 * 1024, // Each part is 100 MiB
    ContentType: &quot;application/octet-stream&quot;
));

foreach (var (partNumber, url) in partUrls)
{
    Console.WriteLine($&quot;Part {partNumber}: {url}&quot;);
}
</code></pre>
<h2 id="signed-headers">Signed Headers</h2>
<p>Include additional headers in the signature to enforce constraints:</p>
<pre><code class="lang-csharp">var url = r2.CreatePresignedPutUrl(&quot;my-bucket&quot;, new PresignedPutRequest(
    Key: &quot;uploads/image.jpg&quot;,
    ExpiresAfter: TimeSpan.FromMinutes(15),
    ContentLength: fileSize,
    ContentType: &quot;image/jpeg&quot;,
    HeadersToSign: new Dictionary&lt;string, string&gt;
    {
        [&quot;x-amz-meta-user-id&quot;] = &quot;user-123&quot;,
        [&quot;x-amz-meta-upload-source&quot;] = &quot;web-app&quot;
    }
));

// Client must include these headers when uploading
</code></pre>
<h2 id="common-patterns">Common Patterns</h2>
<h3 id="secure-file-upload-api">Secure File Upload API</h3>
<pre><code class="lang-csharp">public class SecureUploadService(IR2Client r2)
{
    public UploadSession CreateUploadSession(
        string userId, string fileName, long fileSize, string contentType)
    {
        var key = $&quot;user-uploads/{userId}/{Guid.NewGuid()}/{SanitizeFileName(fileName)}&quot;;

        var url = r2.CreatePresignedPutUrl(&quot;uploads&quot;, new PresignedPutRequest(
            Key: key,
            ExpiresAfter: TimeSpan.FromMinutes(30),
            ContentLength: fileSize,
            ContentType: contentType,
            HeadersToSign: new Dictionary&lt;string, string&gt;
            {
                [&quot;x-amz-meta-user-id&quot;] = userId,
                [&quot;x-amz-meta-original-name&quot;] = fileName
            }
        ));

        return new UploadSession(key, url, DateTime.UtcNow.AddMinutes(30));
    }

    private static string SanitizeFileName(string fileName)
    {
        // Remove dangerous characters
        var invalid = Path.GetInvalidFileNameChars();
        return string.Join(&quot;_&quot;, fileName.Split(invalid));
    }
}

public record UploadSession(string Key, string UploadUrl, DateTime ExpiresAt);
</code></pre>
<h3 id="browser-multipart-upload-flow">Browser Multipart Upload Flow</h3>
<pre><code class="lang-csharp">public class MultipartUploadSession(IR2Client r2)
{
    public async Task&lt;MultipartUploadInfo&gt; InitiateAsync(
        string bucket, string key, long fileSize, long partSize)
    {
        // Calculate number of parts
        var partCount = (int)Math.Ceiling((double)fileSize / partSize);

        // Initiate multipart upload
        var initResult = await r2.InitiateMultipartUploadAsync(bucket, key);
        var uploadId = initResult.Data;

        // Generate presigned URLs for all parts
        var partUrls = r2.CreatePresignedUploadPartsUrls(bucket, new PresignedUploadPartsRequest(
            Key: key,
            UploadId: uploadId,
            PartNumbers: Enumerable.Range(1, partCount).ToArray(),
            ExpiresAfter: TimeSpan.FromHours(24),
            ContentLength: partSize,
            ContentType: &quot;application/octet-stream&quot;
        ));

        return new MultipartUploadInfo(uploadId, partUrls, partSize);
    }

    public async Task CompleteAsync(
        string bucket, string key, string uploadId, IEnumerable&lt;PartETag&gt; parts)
    {
        await r2.CompleteMultipartUploadAsync(bucket, key, uploadId, parts);
    }

    public async Task AbortAsync(string bucket, string key, string uploadId)
    {
        await r2.AbortMultipartUploadAsync(bucket, key, uploadId);
    }
}

public record MultipartUploadInfo(
    string UploadId,
    IReadOnlyDictionary&lt;int, string&gt; PartUrls,
    long PartSize
);
</code></pre>
<h3 id="image-upload-with-validation">Image Upload with Validation</h3>
<pre><code class="lang-csharp">public class ImageUploadService(IR2Client r2)
{
    private static readonly HashSet&lt;string&gt; AllowedTypes = new()
    {
        &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;, &quot;image/webp&quot;
    };

    private const long MaxImageSize = 10 * 1024 * 1024; // 10 MB

    public string? CreateImageUploadUrl(
        string userId, string contentType, long contentLength)
    {
        if (!AllowedTypes.Contains(contentType))
        {
            return null; // Invalid content type
        }

        if (contentLength &gt; MaxImageSize)
        {
            return null; // Too large
        }

        var extension = contentType.Split('/')[1];
        var key = $&quot;images/{userId}/{Guid.NewGuid()}.{extension}&quot;;

        return r2.CreatePresignedPutUrl(&quot;media&quot;, new PresignedPutRequest(
            Key: key,
            ExpiresAfter: TimeSpan.FromMinutes(10),
            ContentLength: contentLength,
            ContentType: contentType
        ));
    }
}
</code></pre>
<h2 id="url-expiration">URL Expiration</h2>
<table>
<thead>
<tr>
<th>Duration</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>5-15 minutes</td>
<td>Interactive uploads</td>
</tr>
<tr>
<td>1 hour</td>
<td>Background processing</td>
</tr>
<tr>
<td>24 hours</td>
<td>Long-running multipart uploads</td>
</tr>
<tr>
<td>7 days (max)</td>
<td>Batch processing</td>
</tr>
</tbody>
</table>
<div class="WARNING">
<h5>Warning</h5>
<p>Keep expiration times short to minimize security risk.</p>
</div>
<h2 id="security-considerations">Security Considerations</h2>
<ol>
<li><strong>Always validate file metadata</strong> before generating URLs</li>
<li><strong>Use short expiration times</strong> when possible</li>
<li><strong>Enforce Content-Length</strong> to prevent quota attacks</li>
<li><strong>Validate Content-Type</strong> to prevent wrong file types</li>
<li><strong>Include user context</strong> in signed headers for auditing</li>
<li><strong>Rate limit</strong> URL generation to prevent abuse</li>
</ol>
<h2 id="error-handling">Error Handling</h2>
<pre><code class="lang-csharp">try
{
    var url = r2.CreatePresignedPutUrl(&quot;bucket&quot;, request);
}
catch (CloudflareR2OperationException ex)
{
    Console.WriteLine($&quot;Failed to generate URL: {ex.Message}&quot;);
}
catch (ArgumentException ex)
{
    Console.WriteLine($&quot;Invalid parameters: {ex.Message}&quot;);
}
</code></pre>
<h2 id="related">Related</h2>
<ul>
<li><a href="uploads.html">Uploading Objects</a> - Server-side uploads</li>
<li><a href="multipart.html">Multipart Uploads</a> - Large file handling</li>
<li><a href="../accounts/r2/cors.html">CORS Configuration</a> - Enable browser uploads</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Alos-no/Cloudflare.NET/blob/main/docs/articles/r2/presigned-urls.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Built and maintained by <a href="https://alos.no" target="_blank" rel="noopener">Alos Engineering</a> Â· Licensed under <a href="https://github.com/Alos-no/Cloudflare.NET/blob/main/LICENSE.txt" target="_blank" rel="noopener">Apache 2.0</a>
        </div>
      </div>
    </footer>
  </body>
</html>
