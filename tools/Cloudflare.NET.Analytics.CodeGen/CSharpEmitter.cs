using System.Text;
using System.Text.RegularExpressions;

// *************************************************************************************************
// Emits C# records/enums from a GraphQL introspection schema.
// - Non-partial, sealed record types with [JsonPropertyName].
// - XML doc comments from schema descriptions (types & fields).
// - Nullable reference types and value types mapped from nullability.
// - Simple include/exclude filtering by regex to scope the output to Analytics datasets.
// *************************************************************************************************

public sealed class CSharpEmitter(string ns, string includeRegex, string excludeRegex, bool verbose = false)
{
  #region Properties & Fields - Non-Public

  private readonly bool _verbose = verbose;

  private readonly Regex? _include = string.IsNullOrWhiteSpace(includeRegex)
    ? null
    : new Regex(includeRegex, RegexOptions.Compiled);
  private readonly Regex _exclude = new(string.IsNullOrWhiteSpace(excludeRegex)
                                          ? "^$"
                                          : excludeRegex, RegexOptions.Compiled);

  // Map GraphQL scalars -> C#.
  private readonly Dictionary<string, string> _scalarMap = new(StringComparer.OrdinalIgnoreCase)
  {
    ["String"]  = "string",
    ["ID"]      = "string",
    ["Boolean"] = "bool",
    ["Int"]     = "int",
    ["Float"]   = "double",
    // Cloudflare Analytics commonly uses custom scalars:
    ["Time"] = "DateTime", // Cloudflare documents Time scalars in Analytics examples. 
    ["Long"] = "long",     // Many byte counters use 64-bit integers.
    // Fallback: anything unknown will default to string (can be overridden here if needed).
  };

  #endregion

  #region Methods

  public string Emit(IntrospectionSchema schema)
  {
    var sb = new StringBuilder();

    sb.AppendLine("// <auto-generated />");
    sb.AppendLine("// This file is generated by Cloudflare.Analytics.CodeGen. Do not edit manually.");
    sb.AppendLine("using System.Text.Json.Serialization;");
    sb.AppendLine();
    sb.AppendLine($"namespace {ns};");
    sb.AppendLine();

    // 1) Collect types of interest
    var types = schema.Types
                      .Where(t => t.Name is not null)
                      .Where(t => !_exclude.IsMatch(t.Name!))
                      .Where(t => _include is null || _include.IsMatch(t.Name!))
                      .OrderBy(t => t.Name, StringComparer.Ordinal)
                      .ToList();

    if (_verbose)
      Console.WriteLine($"Emitting {types.Count} types matching filters...");

    // 2) Emit enums first (they're simple and referenced by objects)
    foreach (var t in types.Where(t => t.Kind == "ENUM"))
      EmitEnum(sb, t);

    // 3) Emit input objects (rarely used in responses but harmless)
    foreach (var t in types.Where(t => t.Kind == "INPUT_OBJECT"))
      EmitInputObject(sb, t, schema);

    // 4) Emit objects
    foreach (var t in types.Where(t => t.Kind == "OBJECT"))
      EmitObject(sb, t, schema);

    return sb.ToString();
  }

  private void EmitEnum(StringBuilder sb, IntrospectionType t)
  {
    if (!string.IsNullOrWhiteSpace(t.Description))
      AppendSummary(sb, t.Description!, "");

    sb.AppendLine($"public enum {SanitizeId(t.Name!)}");
    sb.AppendLine("{");

    var values = t.EnumValues ?? new List<IntrospectionEnumValue>();
    for (int i = 0; i < values.Count; i++)
    {
      var v = values[i];
      if (!string.IsNullOrWhiteSpace(v.Description))
        AppendSummary(sb, v.Description!, "  ");

      sb.AppendLine($"  {SanitizeId(v.Name)}{(i < values.Count - 1 ? "," : string.Empty)}");
    }

    sb.AppendLine("}");
    sb.AppendLine();
  }

  private void EmitInputObject(StringBuilder sb, IntrospectionType t, IntrospectionSchema schema)
  {
    if (!string.IsNullOrWhiteSpace(t.Description))
      AppendSummary(sb, t.Description!, "");

    sb.AppendLine($"public sealed record {SanitizeId(t.Name!)}");
    sb.AppendLine("{");

    foreach (var f in t.InputFields ?? Enumerable.Empty<IntrospectionInputValue>())
    {
      var (csType, nullable) = ResolveCSharpType(f.Type, schema, true);
      var propName = ToPascal(f.Name);

      if (!string.IsNullOrWhiteSpace(f.Description))
        AppendSummary(sb, f.Description!, "  ");

      sb.AppendLine($"  [JsonPropertyName(\"{f.Name}\")]");
      sb.AppendLine($"  public {csType}{(nullable ? "?" : string.Empty)} {propName} {{ get; init; }}");
      sb.AppendLine();
    }

    sb.AppendLine("}");
    sb.AppendLine();
  }

  private void EmitObject(StringBuilder sb, IntrospectionType t, IntrospectionSchema schema)
  {
    // Skip root Query/Mutation/Subscription via exclude regex (already defaulted).
    if (!string.IsNullOrWhiteSpace(t.Description))
      AppendSummary(sb, t.Description!, "");

    sb.AppendLine($"public sealed record {SanitizeId(t.Name!)}");
    sb.AppendLine("{");

    foreach (var f in t.Fields ?? Enumerable.Empty<IntrospectionField>())
    {
      var (csType, nullable) = ResolveCSharpType(f.Type, schema, false);
      var propName = ToPascal(f.Name);

      if (!string.IsNullOrWhiteSpace(f.Description))
        AppendSummary(sb, f.Description!, "  ");

      sb.AppendLine($"  [JsonPropertyName(\"{f.Name}\")]");
      sb.AppendLine($"  public {csType}{(nullable ? "?" : string.Empty)} {propName} {{ get; init; }}");
      sb.AppendLine();
    }

    sb.AppendLine("}");
    sb.AppendLine();
  }

  private (string csType, bool nullable) ResolveCSharpType(IntrospectionTypeRef t, IntrospectionSchema schema, bool forInput)
  {
    // GraphQL type nullability: Non-Null wrapper means NOT nullable.
    // We walk through the wrappers (LIST, NON_NULL) until we reach a named type.
    var isNonNull = false;
    var cur       = t;

    while (cur.Kind == "NON_NULL")
    {
      isNonNull = true;

      // Defensive: if ofType is missing due to a shallow introspection query,
      // bail out gracefully and treat it as a non-null "String" (best-effort).
      if (cur.OfType is null)
        // NOTE: This can occur if the server limits depth or the query fragment isn't deep enough.
        break;

      cur = cur.OfType;
    }

    if (cur.Kind == "LIST")
    {
      // Defensive: if ofType is missing, assume a list of strings to avoid NRE.
      var innerRef = cur.OfType ?? new IntrospectionTypeRef { Kind = "SCALAR", Name = "String" };

      var (inner, innerNullable) = ResolveCSharpType(innerRef, schema, forInput);

      // We prefer List<T> for concrete storage and STJ compatibility.
      var listType = $"List<{inner}{(innerNullable ? "?" : string.Empty)}>";

      return (listType, !isNonNull);
    }

    // Named scalar/enum/object
    var typeName = cur.Name ?? "String";

    // 1) Scalar mapping
    if (_scalarMap.TryGetValue(typeName, out var mapped))
    {
      // Value types become nullable if GraphQL allowed null (i.e., NOT NON_NULL).
      bool needsNullable = !isNonNull && mapped is "bool" or "int" or "double" or "long" or "DateTime";
      return (mapped, needsNullable);
    }

    // 2) Enums/Objects/InputObjects are emitted as C# types with the same name.
    // Assume reference-like (nullable) unless NON_NULL.
    bool nullable = !isNonNull;
    return (SanitizeId(typeName), nullable);
  }

  private static string ToPascal(string name)
  {
    if (string.IsNullOrEmpty(name)) return name;

    // Simple PascalCase transform; preserve existing casing beyond first letter.
    if (char.IsLetter(name[0])) return char.ToUpperInvariant(name[0]) + name.Substring(1);

    return $"_{name}";
  }

  private static string SanitizeId(string raw)
  {
    // Escape reserved keywords and strip invalid chars.
    // For brevity we only handle the common cases here.
    var cleaned = Regex.Replace(raw, @"[^A-Za-z0-9_]", "_");

    return cleaned switch
    {
      "namespace" or "class" or "record" or "event" or "params" or "public" or "private" or "internal" or
        "protected" or "virtual" or "override" or "object" or "string" or "int" or "long" or "float" or "double" or
        "bool" or "using" or "new" => "@" + cleaned,
      _ => cleaned
    };
  }

  private static void AppendSummary(StringBuilder sb, string description, string indent)
  {
    // XML-escape minimal special chars.
    var esc = description.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    sb.AppendLine($"{indent}/// <summary>");

    foreach (var line in esc.Split('\n'))
      sb.AppendLine($"{indent}/// {line.TrimEnd()}");

    sb.AppendLine($"{indent}/// </summary>");
  }

  #endregion
}
